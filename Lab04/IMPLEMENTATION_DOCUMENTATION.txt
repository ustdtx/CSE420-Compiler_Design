================================================================================
               THREE-ADDRESS CODE GENERATION IMPLEMENTATION DOCUMENTATION
                            CSE420 Compiler Design - Lab04
================================================================================

OVERVIEW
--------
This document describes the implementation plan for generating three-address 
intermediate code from a subset of C language programs. The implementation 
follows a two-pass compilation approach:
  1. First Pass: Parse input, perform semantic analysis, and build an AST
  2. Second Pass: Traverse the AST to generate three-address code

The existing codebase already provides:
  - A complete lexical analyzer (lex_analyzer.l)
  - A parser with semantic analysis (syntax_analyzer.y)
  - Symbol table infrastructure (symbol_info.h, symbol_table.h, scope_table.h)
  - Skeleton AST node classes (ast.h)
  - Skeleton code generator (three_addr_code.h)
  - Grammar actions that build AST nodes during parsing

What needs to be implemented:
  - The generate_code() method for each AST node class
  - The ThreeAddrCodeGenerator.generate() method

================================================================================

UNDERSTANDING THREE-ADDRESS CODE
--------------------------------
Three-address code is an intermediate representation where each instruction has
at most three operands. The format used in this assignment follows these conventions:

  Temporary Variables: t0, t1, t2, ...
  Labels: L0, L1, L2, ...
  
Instruction Types:
  1. Binary Operations:     t0 = a + b
  2. Unary Operations:      t0 = -a
  3. Copy Operations:       a = b
  4. Conditional Jump:      if t0 goto L1
  5. Unconditional Jump:    goto L2
  6. Label Definition:      L0:
  7. Function Call:         t0 = call funcname, numargs
  8. Parameter Passing:     param t0
  9. Return Statement:      return t0

================================================================================

IMPLEMENTATION STRATEGY FOR EACH NODE TYPE
------------------------------------------

1. CONSTNODE (Constants: integers and floats)
---------------------------------------------
Purpose: Represents literal numeric values (e.g., 1, 2.5, 100)

Implementation Approach:
  - Generate a new temporary variable (t_n)
  - Output: "t_n = value"
  - Return the temporary variable name

Example:
  Input:  5
  Output: t0 = 5
  Return: "t0"

Why this approach: Constants need to be loaded into temporaries before they
can be used in operations. This simplifies subsequent code generation because
all operands are either temporaries or variables.


2. VARNODE (Variable references and array access)
-------------------------------------------------
Purpose: Represents variable references, including simple variables and array 
element access (a, arr[i])

Implementation Approach:
  A) Simple Variable:
     - Generate a new temporary
     - Output: "t_n = variable_name"
     - Return the temporary

  B) Array Access (arr[index]):
     - First, generate code for the index expression
     - Generate a new temporary for the result
     - Output: "t_n = arr[t_index]"
     - Return the temporary

Example (simple variable):
  Input:  x
  Output: t0 = x
  Return: "t0"

Example (array access):
  Input:  arr[i+1]
  Output: t0 = i
          t1 = 1
          t2 = t0 + t1
          t3 = arr[t2]
  Return: "t3"


3. BINARYOPNODE (Binary operations: +, -, *, /, %, <, >, ==, etc.)
------------------------------------------------------------------
Purpose: Represents operations with two operands

Implementation Approach:
  - Generate code for left operand (gets temporary t_left)
  - Generate code for right operand (gets temporary t_right)
  - Generate new temporary for result
  - Output: "t_result = t_left op t_right"
  - Return t_result

Example:
  Input:  a + b * c
  Output: t0 = a
          t1 = b
          t2 = c
          t3 = t1 * t2
          t4 = t0 + t3
  Return: "t4"

Operators supported:
  - Arithmetic: +, -, *, /, %
  - Relational: <, >, <=, >=, ==, !=
  - Logical: &&, ||


4. UNARYOPNODE (Unary operations: -, !, +)
------------------------------------------
Purpose: Represents operations with one operand

Implementation Approach:
  - Generate code for the operand expression
  - Generate new temporary for result
  - Output: "t_result = op t_operand"
  - Return t_result

Example:
  Input:  -x
  Output: t0 = x
          t1 = -t0
  Return: "t1"

Special case for logical NOT (!):
  - Output: "t_result = !t_operand"


5. ASSIGNNODE (Assignment: variable = expression)
-------------------------------------------------
Purpose: Represents assignment operations

Implementation Approach:
  A) Simple Variable Assignment (x = expr):
     - Generate code for right-hand side expression
     - Output: "variable_name = t_rhs"
     - Return t_rhs (assignments are expressions in C)

  B) Array Assignment (arr[i] = expr):
     - Generate code for index expression
     - Generate code for right-hand side expression
     - Output: "arr[t_index] = t_rhs"
     - Return t_rhs

Example:
  Input:  x = a + b
  Output: t0 = a
          t1 = b
          t2 = t0 + t1
          x = t2
  Return: "t2"


6. EXPRSTMTNODE (Expression statements)
---------------------------------------
Purpose: Wraps expressions as statements (e.g., function calls, assignments)

Implementation Approach:
  - Simply generate code for the contained expression
  - Return empty string (statements don't produce values)

Example:
  Input:  x = 5;
  Output: t0 = 5
          x = t0


7. BLOCKNODE (Compound statements: { ... })
-------------------------------------------
Purpose: Contains a sequence of statements

Implementation Approach:
  - Iterate through all contained statements
  - Generate code for each statement in order
  - Return empty string

Example:
  Input:  { x = 1; y = 2; }
  Output: t0 = 1
          x = t0
          t1 = 2
          y = t1


8. IFNODE (If-else statements)
------------------------------
Purpose: Represents conditional execution

Implementation Approach:
  A) If without else:
     - Generate code for condition
     - L_then = new_label
     - L_end = new_label
     - Output: "if t_cond goto L_then"
     - Output: "goto L_end"
     - Output: "L_then:"
     - Generate code for then-block
     - Output: "L_end:"

  B) If-else:
     - Generate code for condition
     - L_then = new_label
     - L_else = new_label
     - L_end = new_label
     - Output: "if t_cond goto L_then"
     - Output: "goto L_else"
     - Output: "L_then:"
     - Generate code for then-block
     - Output: "goto L_end"
     - Output: "L_else:"
     - Generate code for else-block
     - Output: "L_end:"

Example:
  Input:  if (x > 0) y = 1; else y = 2;
  Output: t0 = x
          t1 = 0
          t2 = t0 > t1
          if t2 goto L0
          goto L1
          L0:
          t3 = 1
          y = t3
          goto L2
          L1:
          t4 = 2
          y = t4
          L2:


9. WHILENODE (While loops)
--------------------------
Purpose: Represents while loop constructs

Implementation Approach:
  - L_start = new_label
  - L_body = new_label
  - L_end = new_label
  - Output: "L_start:"
  - Generate code for condition
  - Output: "if t_cond goto L_body"
  - Output: "goto L_end"
  - Output: "L_body:"
  - Generate code for body
  - Output: "goto L_start"
  - Output: "L_end:"

Example:
  Input:  while (x > 0) x--;
  Output: L0:
          t0 = x
          t1 = 0
          t2 = t0 > t1
          if t2 goto L1
          goto L2
          L1:
          t3 = 1
          t4 = x - t3
          x = t4
          goto L0
          L2:


10. FORNODE (For loops)
-----------------------
Purpose: Represents for loop constructs

Implementation Approach:
  For loop: for(init; cond; update) body
  Equivalent to: init; while(cond) { body; update; }
  
  - Generate code for initialization expression
  - L_start = new_label
  - L_body = new_label  
  - L_end = new_label
  - Output: "L_start:"
  - Generate code for condition
  - Output: "if t_cond goto L_body"
  - Output: "goto L_end"
  - Output: "L_body:"
  - Generate code for body
  - Generate code for update expression
  - Output: "goto L_start"
  - Output: "L_end:"

Example:
  Input:  for(i=0; i<10; i++) sum = sum + i;
  Output: t0 = 0
          i = t0
          L0:
          t1 = i
          t2 = 10
          t3 = t1 < t2
          if t3 goto L1
          goto L2
          L1:
          t4 = sum
          t5 = t1
          t6 = t4 + t5
          sum = t6
          t7 = 1
          t8 = t1 + t7
          i = t8
          goto L0
          L2:


11. RETURNNODE (Return statements)
----------------------------------
Purpose: Represents function return statements

Implementation Approach:
  - If has expression: generate code for expression
  - Output: "return t_expr" or "return" (for void functions)

Example:
  Input:  return x + 1;
  Output: t0 = x
          t1 = 1
          t2 = t0 + t1
          return t2


12. DECLNODE (Variable declarations)
------------------------------------
Purpose: Represents variable and array declarations

Implementation Approach:
  - For this intermediate representation, declarations are noted as comments
  - Output: "// Declaration: type varname" for each variable
  - Output: "// Declaration: type varname[size]" for arrays
  - No actual code generated (memory allocation is backend concern)

Example:
  Input:  int a, b, arr[10];
  Output: // Declaration: int a
          // Declaration: int b
          // Declaration: int arr[10]


13. FUNCDECLNODE (Function definitions)
---------------------------------------
Purpose: Represents function definitions

Implementation Approach:
  - Output: "// Function: returntype funcname(params)"
  - Generate code for function body
  - The function body is a BlockNode

Example:
  Input:  int add(int a, int b) { return a + b; }
  Output: // Function: int add(int a, int b)
          t0 = a
          t1 = b
          t2 = t0 + t1
          return t2


14. FUNCCALLNODE (Function calls)
---------------------------------
Purpose: Represents function invocations

Implementation Approach:
  - Generate code for each argument expression
  - For each argument: Output "param t_arg"
  - Generate new temporary for result
  - Output: "t_result = call funcname, num_args"
  - Return t_result

Example:
  Input:  result = add(x, y);
  Output: t0 = x
          param t0
          t1 = y
          param t1
          t2 = call add, 2
          result = t2


15. PROGRAMNODE (Program root)
------------------------------
Purpose: Root of the AST containing all units (functions, global declarations)

Implementation Approach:
  - Output file header comments
  - Iterate through all units
  - Generate code for each unit
  - Output file footer comments


================================================================================

THREEADDRCODEGENERATOR CLASS IMPLEMENTATION
-------------------------------------------
The generate() method in ThreeAddrCodeGenerator should:

1. Write header comments to output file:
   //========== THREE ADDRESS CODE ==========
   // This code was generated by a two-pass compiler
   // Format: 
   // - t0, t1, etc. are temporary variables
   // - L0, L1, etc. are labels for jumps
   // - Operations follow the three-address code format
   // Three Address Code

2. Call ast_root->generate_code() to traverse the AST

3. Write footer comments:
   //========== END OF CODE ==========


================================================================================

IMPLEMENTATION ORDER
--------------------
The implementation should proceed in this order to ensure dependencies are met:

Phase 1 - Basic Expressions (leaf nodes and simple operations):
  1. ConstNode.generate_code()     - Constants are fundamental
  2. VarNode.generate_code()       - Variables including array access
  3. BinaryOpNode.generate_code()  - Arithmetic, relational, logical ops
  4. UnaryOpNode.generate_code()   - Unary minus, logical not
  5. AssignNode.generate_code()    - Assignment operations

Phase 2 - Statements:
  6. ExprStmtNode.generate_code()  - Expression statements
  7. DeclNode.generate_code()      - Variable declarations
  8. BlockNode.generate_code()     - Compound statements
  9. ReturnNode.generate_code()    - Return statements

Phase 3 - Control Flow:
  10. IfNode.generate_code()       - Conditional statements
  11. WhileNode.generate_code()    - While loops
  12. ForNode.generate_code()      - For loops

Phase 4 - Functions:
  13. FuncCallNode.generate_code() - Function calls
  14. FuncDeclNode.generate_code() - Function definitions
  15. ProgramNode.generate_code()  - Program root

Phase 5 - Code Generator:
  16. ThreeAddrCodeGenerator.generate() - Main entry point


================================================================================

KEY IMPLEMENTATION DETAILS
--------------------------

1. Temporary Variable Management:
   - temp_count is passed by reference to all generate_code methods
   - Each new temporary increments temp_count
   - Format: "t" + to_string(temp_count++)

2. Label Management:
   - label_count is passed by reference to all generate_code methods
   - Each new label increments label_count
   - Format: "L" + to_string(label_count++)

3. Symbol-to-Temp Mapping:
   - symbol_to_temp map tracks which variables have been assigned to temporaries
   - This is optional and may be used for optimization

4. Return Values:
   - Expression nodes return the temporary holding their result
   - Statement nodes return empty string (they don't produce values)

5. Code Output:
   - All output goes through the ofstream& outcode parameter
   - Each instruction on its own line
   - Comments use // prefix
   - Labels end with :


================================================================================

EXPECTED OUTPUT FORMAT
----------------------
Based on the sample outputs, the three-address code should look like:

//========== THREE ADDRESS CODE ==========

// This code was generated by a two-pass compiler
// Format: 
// - t0, t1, etc. are temporary variables
// - L0, L1, etc. are labels for jumps
// - Operations follow the three-address code format

// Three Address Code

// Function: int funcname(params)
t0 = a
t1 = b
t2 = t0 + t1
return t2

// Function: void main()
// Declaration: int x
t3 = 1
x = t3
L0:
t4 = x
t5 = 10
t6 = t4 < t5
if t6 goto L1
goto L2
L1:
// loop body code
goto L0
L2:


//========== END OF CODE ==========


================================================================================

NOTES AND CONSIDERATIONS
------------------------

1. The parser (syntax_analyzer.y) already creates AST nodes during parsing.
   The generate_code() methods just need to traverse and emit code.

2. Increment/Decrement operators (++, --) are handled in the parser by 
   creating equivalent AST structures (x++ becomes x = x + 1).

3. The printf statement is treated as a simple expression statement in 
   this implementation.

4. Error handling: If there are parsing/semantic errors, code generation
   is skipped (handled in main()).

5. Memory management: The AST nodes use raw pointers with delete in 
   destructors. Be careful about double-deletion.

================================================================================
                              END OF DOCUMENTATION
================================================================================
